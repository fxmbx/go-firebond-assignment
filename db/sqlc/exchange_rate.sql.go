// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: exchange_rate.sql

package db

import (
	"context"
	"database/sql"
)

const getCurrentCryptoExchangeRate = `-- name: GetCurrentCryptoExchangeRate :many
SELECT
	subquery.id,
	subquery.created_at,
	subquery. "crypto_currency_Id",
	subquery.fiat_currency_acronym,
	subquery.exchanage_rate,
	row_num
FROM (
	SELECT
		id,
		created_at,
		"crypto_currency_Id",
		fiat_currency_acronym,
		exchanage_rate,
		ROW_NUMBER() OVER (PARTITION BY "crypto_currency_Id",
			fiat_currency_acronym ORDER BY created_at DESC) AS row_num
	FROM
		"exchange_rate") subquery
WHERE
	row_num = 1
	AND "crypto_currency_Id" = $1
`

type GetCurrentCryptoExchangeRateRow struct {
	ID                  int32          `json:"id"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	CryptoCurrencyId    sql.NullString `json:"crypto_currency_Id"`
	FiatCurrencyAcronym sql.NullString `json:"fiat_currency_acronym"`
	ExchanageRate       string         `json:"exchanage_rate"`
	RowNum              int64          `json:"row_num"`
}

func (q *Queries) GetCurrentCryptoExchangeRate(ctx context.Context, cryptoCurrencyId sql.NullString) ([]GetCurrentCryptoExchangeRateRow, error) {
	rows, err := q.db.QueryContext(ctx, getCurrentCryptoExchangeRate, cryptoCurrencyId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCurrentCryptoExchangeRateRow{}
	for rows.Next() {
		var i GetCurrentCryptoExchangeRateRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.CryptoCurrencyId,
			&i.FiatCurrencyAcronym,
			&i.ExchanageRate,
			&i.RowNum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentCryptoFiatRate = `-- name: GetCurrentCryptoFiatRate :one
SELECT
		subquery.id, subquery.created_at, subquery."crypto_currency_Id", subquery.fiat_currency_acronym, subquery.exchanage_rate, row_num
	FROM (
		SELECT
			id,
			created_at,
			"crypto_currency_Id",
			fiat_currency_acronym,
			exchanage_rate,
			ROW_NUMBER() OVER (PARTITION BY "crypto_currency_Id",
				fiat_currency_acronym ORDER BY created_at DESC) AS row_num
		FROM
			"exchange_rate") subquery
WHERE
	subquery.row_num = 1 AND "crypto_currency_Id" = $1 AND fiat_currency_acronym = $2
`

type GetCurrentCryptoFiatRateParams struct {
	CryptoCurrencyId    sql.NullString `json:"crypto_currency_Id"`
	FiatCurrencyAcronym sql.NullString `json:"fiat_currency_acronym"`
}

type GetCurrentCryptoFiatRateRow struct {
	ID                  int32          `json:"id"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	CryptoCurrencyId    sql.NullString `json:"crypto_currency_Id"`
	FiatCurrencyAcronym sql.NullString `json:"fiat_currency_acronym"`
	ExchanageRate       string         `json:"exchanage_rate"`
	RowNum              int64          `json:"row_num"`
}

func (q *Queries) GetCurrentCryptoFiatRate(ctx context.Context, arg GetCurrentCryptoFiatRateParams) (GetCurrentCryptoFiatRateRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentCryptoFiatRate, arg.CryptoCurrencyId, arg.FiatCurrencyAcronym)
	var i GetCurrentCryptoFiatRateRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.CryptoCurrencyId,
		&i.FiatCurrencyAcronym,
		&i.ExchanageRate,
		&i.RowNum,
	)
	return i, err
}

const getCurrentExchangeRates = `-- name: GetCurrentExchangeRates :many
SELECT
		subquery.id, subquery.created_at, subquery."crypto_currency_Id", subquery.fiat_currency_acronym, subquery.exchanage_rate, row_num
	FROM (
		SELECT
			id,
			created_at,
			"crypto_currency_Id",
			fiat_currency_acronym,
			exchanage_rate,
			ROW_NUMBER() OVER (PARTITION BY "crypto_currency_Id",
				fiat_currency_acronym ORDER BY created_at DESC) AS row_num
		FROM
			"exchange_rate") subquery
WHERE
	subquery.row_num = 1
`

type GetCurrentExchangeRatesRow struct {
	ID                  int32          `json:"id"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	CryptoCurrencyId    sql.NullString `json:"crypto_currency_Id"`
	FiatCurrencyAcronym sql.NullString `json:"fiat_currency_acronym"`
	ExchanageRate       string         `json:"exchanage_rate"`
	RowNum              int64          `json:"row_num"`
}

func (q *Queries) GetCurrentExchangeRates(ctx context.Context) ([]GetCurrentExchangeRatesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCurrentExchangeRates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCurrentExchangeRatesRow{}
	for rows.Next() {
		var i GetCurrentExchangeRatesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.CryptoCurrencyId,
			&i.FiatCurrencyAcronym,
			&i.ExchanageRate,
			&i.RowNum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExchangeRateHistory = `-- name: GetExchangeRateHistory :many
SELECT
		subquery.id, subquery.created_at, subquery."crypto_currency_Id", subquery.fiat_currency_acronym, subquery.exchanage_rate, row_num
	FROM (
		SELECT
			id,
			created_at,
			"crypto_currency_Id",
			fiat_currency_acronym,
			exchanage_rate,
			ROW_NUMBER() OVER (PARTITION BY "crypto_currency_Id",
				fiat_currency_acronym ORDER BY created_at DESC) AS row_num
		FROM
			"exchange_rate"
      WHERE created_at >= NOW() - INTERVAL '24 hours'
      ) subquery
WHERE
  "crypto_currency_Id" = $1 AND fiat_currency_acronym = $2
`

type GetExchangeRateHistoryParams struct {
	CryptoCurrencyId    sql.NullString `json:"crypto_currency_Id"`
	FiatCurrencyAcronym sql.NullString `json:"fiat_currency_acronym"`
}

type GetExchangeRateHistoryRow struct {
	ID                  int32          `json:"id"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	CryptoCurrencyId    sql.NullString `json:"crypto_currency_Id"`
	FiatCurrencyAcronym sql.NullString `json:"fiat_currency_acronym"`
	ExchanageRate       string         `json:"exchanage_rate"`
	RowNum              int64          `json:"row_num"`
}

func (q *Queries) GetExchangeRateHistory(ctx context.Context, arg GetExchangeRateHistoryParams) ([]GetExchangeRateHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getExchangeRateHistory, arg.CryptoCurrencyId, arg.FiatCurrencyAcronym)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExchangeRateHistoryRow{}
	for rows.Next() {
		var i GetExchangeRateHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.CryptoCurrencyId,
			&i.FiatCurrencyAcronym,
			&i.ExchanageRate,
			&i.RowNum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertExchangeRate = `-- name: InsertExchangeRate :one
INSERT INTO "exchange_rate" (
  "crypto_currency_Id",
  fiat_currency_acronym,
  exchanage_rate
) VALUES (
  $1, $2, $3
)
RETURNING id, created_at, "crypto_currency_Id", fiat_currency_acronym, exchanage_rate
`

type InsertExchangeRateParams struct {
	CryptoCurrencyId    sql.NullString `json:"crypto_currency_Id"`
	FiatCurrencyAcronym sql.NullString `json:"fiat_currency_acronym"`
	ExchanageRate       string         `json:"exchanage_rate"`
}

func (q *Queries) InsertExchangeRate(ctx context.Context, arg InsertExchangeRateParams) (ExchangeRate, error) {
	row := q.db.QueryRowContext(ctx, insertExchangeRate, arg.CryptoCurrencyId, arg.FiatCurrencyAcronym, arg.ExchanageRate)
	var i ExchangeRate
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.CryptoCurrencyId,
		&i.FiatCurrencyAcronym,
		&i.ExchanageRate,
	)
	return i, err
}
